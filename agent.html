<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
  background: #f4f7f9;
  display: flex;
  flex-direction: column;
}

header {
  background: linear-gradient(90deg, #ff5f6d, #ffc371, #ff9a9e, #f77062);
  color: white;
  padding: 12px;
  text-align: center;
  font-size: 20px;
  font-weight: bold;
  border-bottom: 2px solid #ff9a9e;
  border-radius: 0 0 15px 15px;
}

#online-status {
  text-align: center;
  font-size: 15px;
  color: #28a745;
  margin-top: 6px;
  font-weight: bold;
}

#ticket-status {
  text-align: center;
  font-size: 14px;
  color: #333;
  margin-top: 6px;
}

#live-typing {
  text-align: center;
  font-size: 14px;
  color: #ff69b4;
  margin: 4px 0;
  font-style: italic;
}

#chat-container {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  padding: 10px;
  overflow-y: auto;
}

.message {
  max-width: 80%;
  margin: 4px 0;
  padding: 8px 12px;
  border-radius: 12px;
  word-wrap: break-word;
  /* Preserve user-entered line breaks and spacing */
  white-space: pre-wrap;
}

.user-msg { background: #ffc0cb; align-self: flex-start; }
.agent-msg { background: #ffffff; border: 1px solid #ddd; align-self: flex-end; }

#input-container {
  flex-shrink: 0;
  display: flex;
  padding: 10px;
  background: #fff;
  border-top: 1px solid #ccc;
}

#msg {
  flex: 1;
  padding: 8px 12px;
  border-radius: 20px;
  border: 1px solid #ccc;
  font-size: 14px;
  resize: none;
}

#send-btn {
  margin-left: 8px;
  padding: 8px 16px;
  border: none;
  background: linear-gradient(90deg, #ff5f6d, #ffc371);
  color: white;
  border-radius: 20px;
  font-size: 14px;
  cursor: pointer;
}

#send-btn:active { opacity: 0.8; }
</style>
</head>
<body>

<header>Agent Panel</header>
<div id="online-status">User Offline ‚ùå</div>
<div id="ticket-status">Ticket: Unread</div>
<div id="live-typing"></div>

<div id="chat-container"></div>

<div id="input-container">
  <textarea id="msg" placeholder="Type message..." rows="2" enterkeyhint="enter"></textarea>
  <button id="send-btn" type="button">Send</button>
</div>

<script>
const baseUrl = "https://chatbot-788207962975.us-central1.run.app";
const chatId = "1234";

const msgInput = document.getElementById("msg");
const chatContainer = document.getElementById("chat-container");

const localRole = 'agent';
let lastMessageCount = 0; // track messages to prevent duplicate rendering when appending locally

const ticketStatusEl = document.getElementById('ticket-status');
let ticketRead = false;
let _lastObservedMsg = null;

function markTicketRead(reader) {
  if (ticketRead) return;
  ticketRead = true;
  if (ticketStatusEl) ticketStatusEl.textContent = 'Ticket: Read ‚úÖ';

  // NOTE: Assumes a server endpoint exists to mark the ticket/message as read.
  // Sending { chat_id, reader } to `${baseUrl}/mark_read`.
  // Update the endpoint/payload if your server expects a different format.
  fetch(`${baseUrl}/mark_read`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ chat_id: chatId, reader })
  }).catch(() => { /* ignore network errors */ });
}

const _observer = new IntersectionObserver(entries => {
  for (const entry of entries) {
    if (entry.isIntersecting) {
      // Agent viewing the messages; mark ticket read by agent
      markTicketRead('agent');
    }
  }
}, { root: chatContainer, threshold: 0.9 });

function observeLastMessage(shouldObserve) {
  try {
    if (_lastObservedMsg) {
      _observer.unobserve(_lastObservedMsg);
      _lastObservedMsg = null;
    }
    if (!shouldObserve) return;
    const last = chatContainer.lastElementChild;
    if (last) {
      _observer.observe(last);
      _lastObservedMsg = last;
    }
  } catch (e) { /* safe fallback */ }
}

// ---------- Load existing messages ----------
async function loadMessages() {
  const res = await fetch(`${baseUrl}/messages/${chatId}`);
  const data = await res.json();

  // Preserve whether the message input currently has focus so we can restore it
  const inputWasFocused = (document.activeElement === msgInput);

  // Append only new messages to avoid duplicating messages that we appended locally
  for (let i = lastMessageCount; i < data.length; i++) {
    const msg = data[i];
    const div = document.createElement("div");
    div.className = "message " + (msg.sender === "user" ? "user-msg" : "agent-msg");
    div.textContent = msg.text;
    chatContainer.appendChild(div);
  }

  lastMessageCount = data.length;
  chatContainer.scrollTop = chatContainer.scrollHeight;

  if (inputWasFocused) {
    // Re-focus and move caret to end to keep the keyboard visible and the input usable
    msgInput.focus();
    const len = msgInput.value.length;
    try { msgInput.setSelectionRange(len, len); } catch (e) { /* ignore on unsupported */ }
  }
  // Update ticket status if the last message has been seen by the other side
  if (data.length > 0) {
    const lastMsg = data[data.length - 1];
    const other = localRole === 'agent' ? 'user' : 'agent';
    if (lastMsg.seen_by && Array.isArray(lastMsg.seen_by) && lastMsg.seen_by.includes(other)) {
      if (ticketStatusEl) ticketStatusEl.textContent = 'Ticket: Read ‚úÖ';
      ticketRead = true;
    } else {
      if (ticketStatusEl && !ticketRead) ticketStatusEl.textContent = 'Ticket: Unread';
    }
    // Observe the last message only if the last message was sent by the other party
    const shouldObserve = lastMsg.sender !== localRole;
    observeLastMessage(shouldObserve);
  } else {
    observeLastMessage(false);
  }
}

// ---------- Send agent message ----------
async function sendMessage() {
  const message = msgInput.value.trim();
  if (!message) return;

  await fetch(`${baseUrl}/send`, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({chat_id: chatId, sender: "agent", text: message})
  });

  // Append message directly to avoid keyboard flicker
  const div = document.createElement("div");
  div.className = "message agent-msg";
  div.textContent = message;
  chatContainer.appendChild(div);
  chatContainer.scrollTop = chatContainer.scrollHeight;

  msgInput.value = "";
  // increment lastMessageCount because we appended the message locally
  lastMessageCount++;
  // keep keyboard open
  msgInput.focus();
  // After sending our own message we should not observe it for read by this client
  observeLastMessage(false);
  // Mark ticket unread locally until the other side reads it
  ticketRead = false;
  if (ticketStatusEl) ticketStatusEl.textContent = 'Ticket: Unread';
}

// ---------- Check user online status ----------
async function checkOnline() {
  const res = await fetch(`${baseUrl}/is_online/${chatId}`);
  const data = await res.json();
  const status = document.getElementById("online-status");
  status.textContent = data.user_online ? "User Online üü¢" : "User Offline ‚ùå";
}

// ---------- Load live typing ----------
async function loadLiveTyping() {
  const res = await fetch(`${baseUrl}/get_live_typing/${chatId}`);
  const data = await res.json();
  const typingElem = document.getElementById("live-typing");
  typingElem.textContent = data.text ? `Typing: ${data.text}` : "";
}

// ---------- Event listeners ----------
document.getElementById("send-btn").addEventListener("click", sendMessage);

// Allow Enter to insert a newline. Use Ctrl+Enter or Cmd+Enter to send.
msgInput.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault(); // prevent inserting newline when sending
      sendMessage();
    }
    // otherwise allow newline to be inserted by the textarea
  }
});

// ---------- Logout agent ----------
window.addEventListener("beforeunload", async () => {
  await fetch(`${baseUrl}/logout_agent`, { method: "POST", headers: {"Content-Type": "application/json"} });
});

// ---------- Intervals ----------
setInterval(loadMessages, 1500);
setInterval(checkOnline, 1000);
// Poll live-typing at a slightly lower frequency to reduce frequent DOM updates
setInterval(loadLiveTyping, 500);

loadMessages();
checkOnline();
</script>
</body>
</html>
